"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOWPASS = 0;
var HIGHPASS = 1;
var BANDPASS = 2;
var LOWSHELF = 3;
var HIGHSHELF = 4;
var PEAKING = 5;
var NOTCH = 6;
var ALLPASS = 7;

var FilterTypes = [LOWPASS, HIGHPASS, BANDPASS, LOWSHELF, HIGHSHELF, PEAKING, NOTCH, ALLPASS];
var computeCoefficients = {};

var BiquadFilterNodeDSP = {
  dspInit: function dspInit() {
    this._kernels = [];
    this._quantumStartFrame = -1;
    this._coefficients = [0, 0, 0, 0, 0];
    this._prevFrequency = 0;
    this._prevDetune = 0;
    this._prevQ = 0;
    this._prevGain = 0;
  },
  dspUpdateKernel: function dspUpdateKernel(numberOfChannels) {
    if (numberOfChannels < this._kernels.length) {
      this._kernels.splice(numberOfChannels);
    } else if (this._kernels.length < numberOfChannels) {
      while (numberOfChannels !== this._kernels.length) {
        this._kernels.push(new BiquadFilterKernel(this, this._kernels.length));
      }
    }

    switch (numberOfChannels) {
      case 1:
        this.dspProcess = this.dspProcess1;
        break;
      case 2:
        this.dspProcess = this.dspProcess2;
        break;
      default:
        this.dspProcess = this.dspProcessN;
        break;
    }
  },
  dspProcess1: function dspProcess1() {
    var blockSize = this.blockSize;
    var quantumStartFrame = this.context.currentSampleFrame;
    var quantumEndFrame = quantumStartFrame + blockSize;
    var inputs = this.inputs[0].bus.getChannelData();
    var outputs = this.outputs[0].bus.getMutableData();
    var isCoefficientsUpdated = this.dspUpdateCoefficients();
    var coefficients = this._coefficients;
    var kernels = this._kernels;

    if (quantumStartFrame !== this._quantumStartFrame) {
      kernels[0].processWithInitCoefficients(coefficients, inputs[0], outputs[0], blockSize);
    } else if (isCoefficientsUpdated) {
      kernels[0].processWithCoefficients(coefficients, inputs[0], outputs[0], blockSize);
    } else {
      kernels[0].process(inputs[0], outputs[0], blockSize);
    }

    this._quantumStartFrame = quantumEndFrame;
  },
  dspProcess2: function dspProcess2() {
    var blockSize = this.blockSize;
    var quantumStartFrame = this.context.currentSampleFrame;
    var quantumEndFrame = quantumStartFrame + blockSize;
    var inputs = this.inputs[0].bus.getChannelData();
    var outputs = this.outputs[0].bus.getMutableData();
    var isCoefficientsUpdated = this.dspUpdateCoefficients();
    var coefficients = this._coefficients;
    var kernels = this._kernels;

    if (quantumStartFrame !== this._quantumStartFrame) {
      kernels[0].processWithInitCoefficients(coefficients, inputs[0], outputs[0], blockSize);
      kernels[1].processWithInitCoefficients(coefficients, inputs[1], outputs[1], blockSize);
    } else if (isCoefficientsUpdated) {
      kernels[0].processWithCoefficients(coefficients, inputs[0], outputs[0], blockSize);
      kernels[1].processWithCoefficients(coefficients, inputs[1], outputs[1], blockSize);
    } else {
      kernels[0].process(inputs[0], outputs[0], blockSize);
      kernels[1].process(inputs[1], outputs[1], blockSize);
    }

    this._quantumStartFrame = quantumEndFrame;
  },
  dspProcessN: function dspProcessN() {
    var blockSize = this.blockSize;
    var quantumStartFrame = this.context.currentSampleFrame;
    var quantumEndFrame = quantumStartFrame + blockSize;
    var inputs = this.inputs[0].bus.getChannelData();
    var outputs = this.outputs[0].bus.getMutableData();
    var isCoefficientsUpdated = this.dspUpdateCoefficients();
    var coefficients = this._coefficients;
    var kernels = this._kernels;

    if (quantumStartFrame !== this._quantumStartFrame) {
      for (var i = 0, imax = kernels.length; i < imax; i++) {
        kernels[i].processWithInitCoefficients(coefficients, inputs[i], outputs[i], blockSize);
      }
    } else if (isCoefficientsUpdated) {
      for (var _i = 0, _imax = kernels.length; _i < _imax; _i++) {
        kernels[_i].processWithCoefficients(coefficients, inputs[_i], outputs[_i], blockSize);
      }
    } else {
      for (var _i2 = 0, _imax2 = kernels.length; _i2 < _imax2; _i2++) {
        kernels[_i2].process(inputs[_i2], outputs[_i2], blockSize);
      }
    }

    this._quantumStartFrame = quantumEndFrame;
  },
  dspUpdateCoefficients: function dspUpdateCoefficients() {
    var frequency = this._frequency.getValue();
    var detune = this._detune.getValue();
    var Q = this._Q.getValue();
    var gain = this._gain.getValue();

    if (frequency === this._prevFrequency && detune === this._prevDetune && Q === this._prevQ && gain === this._prevGain) {
      return false;
    }

    var nyquist = this.sampleRate * 0.5;
    var normalizedFrequency = frequency / nyquist * Math.pow(2, detune / 1200);

    this._coefficients = computeCoefficients[this._type](normalizedFrequency, Q, gain);
    this._prevFrequency = frequency;
    this._prevDetune = detune;
    this._prevQ = Q;
    this._prevGain = gain;

    return true;
  }
};

var BiquadFilterKernel = function () {
  function BiquadFilterKernel() {
    _classCallCheck(this, BiquadFilterKernel);

    this._coefficients = [0, 0, 0, 0, 0];
    this._x1 = 0;
    this._x2 = 0;
    this._y1 = 0;
    this._y2 = 0;
  }

  _createClass(BiquadFilterKernel, [{
    key: "processWithInitCoefficients",
    value: function processWithInitCoefficients(coefficients, input, output, inNumSamples) {
      this._coefficients = coefficients;
      this.process(input, output, inNumSamples);
    }
  }, {
    key: "process",
    value: function process(input, output, inNumSamples) {
      var b0 = this._coefficients[0];
      var b1 = this._coefficients[1];
      var b2 = this._coefficients[2];
      var a1 = this._coefficients[3];
      var a2 = this._coefficients[4];

      var x0 = void 0;
      var x1 = this._x1;
      var x2 = this._x2;
      var y0 = void 0;
      var y1 = this._y1;
      var y2 = this._y2;

      for (var i = 0; i < inNumSamples; i++) {
        x0 = input[i];
        y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;

        x2 = x1;
        x1 = x0;
        y2 = y1;
        y1 = y0;

        output[i] = y0;
      }

      this._x1 = flushDenormalFloatToZero(x1);
      this._x2 = flushDenormalFloatToZero(x2);
      this._y1 = flushDenormalFloatToZero(y1);
      this._y2 = flushDenormalFloatToZero(y2);
    }
  }, {
    key: "processWithCoefficients",
    value: function processWithCoefficients(coefficients, input, output, inNumSamples) {
      var b0 = this._coefficients[0];
      var b1 = this._coefficients[1];
      var b2 = this._coefficients[2];
      var a1 = this._coefficients[3];
      var a2 = this._coefficients[4];
      var x0 = void 0;
      var x1 = this._x1;
      var x2 = this._x2;
      var y0 = void 0;
      var y1 = this._y1;
      var y2 = this._y2;

      var step = 1 / inNumSamples;
      var b0Incr = (coefficients[0] - b0) * step;
      var b1Incr = (coefficients[1] - b1) * step;
      var b2Incr = (coefficients[2] - b2) * step;
      var a1Incr = (coefficients[3] - a1) * step;
      var a2Incr = (coefficients[4] - a2) * step;

      for (var i = 0; i < inNumSamples; i++) {
        x0 = input[i];
        y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;

        x2 = x1;
        x1 = x0;
        y2 = y1;
        y1 = y0;

        b0 += b0Incr;
        b1 += b1Incr;
        b2 += b2Incr;
        a1 += a1Incr;
        a2 += a2Incr;

        output[i] = y0;
      }

      this._x1 = flushDenormalFloatToZero(x1);
      this._x2 = flushDenormalFloatToZero(x2);
      this._y1 = flushDenormalFloatToZero(y1);
      this._y2 = flushDenormalFloatToZero(y2);
      this._coefficients = coefficients;
    }
  }]);

  return BiquadFilterKernel;
}();

computeCoefficients[LOWPASS] = function (cutoff, resonance) {
  cutoff = Math.max(0.0, Math.min(cutoff, 1.0));

  if (cutoff === 1) {
    return [1, 0, 0, 0, 0];
  }

  if (0 < cutoff) {
    resonance = Math.max(0.0, resonance);

    var g = Math.pow(10.0, 0.05 * resonance);
    var d = Math.sqrt((4 - Math.sqrt(16 - 16 / (g * g))) / 2);
    var theta = Math.PI * cutoff;
    var sn = 0.5 * d * Math.sin(theta);
    var beta = 0.5 * (1 - sn) / (1 + sn);
    var gamma = (0.5 + beta) * Math.cos(theta);
    var alpha = 0.25 * (0.5 + beta - gamma);

    var b0 = 2 * alpha;
    var b1 = 2 * 2 * alpha;
    var b2 = 2 * alpha;
    var a1 = 2 * -gamma;
    var a2 = 2 * beta;

    return [b0, b1, b2, a1, a2];
  }

  return [0, 0, 0, 0, 0];
};

computeCoefficients[HIGHPASS] = function (cutoff, resonance) {
  cutoff = Math.max(0.0, Math.min(cutoff, 1.0));

  if (cutoff == 1) {
    return [0, 0, 0, 0, 0];
  }

  if (0 < cutoff) {
    resonance = Math.max(0.0, resonance);

    var g = Math.pow(10.0, 0.05 * resonance);
    var d = Math.sqrt((4 - Math.sqrt(16 - 16 / (g * g))) / 2);
    var theta = Math.PI * cutoff;
    var sn = 0.5 * d * Math.sin(theta);
    var beta = 0.5 * (1 - sn) / (1 + sn);
    var gamma = (0.5 + beta) * Math.cos(theta);
    var alpha = 0.25 * (0.5 + beta + gamma);

    var b0 = 2 * alpha;
    var b1 = 2 * -2 * alpha;
    var b2 = 2 * alpha;
    var a1 = 2 * -gamma;
    var a2 = 2 * beta;

    return [b0, b1, b2, a1, a2];
  }

  return [1, 0, 0, 0, 0];
};

computeCoefficients[BANDPASS] = function (frequency, Q) {
  frequency = Math.max(0.0, frequency);
  Q = Math.max(0.0, Q);

  if (0 < frequency && frequency < 1) {
    var w0 = Math.PI * frequency;

    if (0 < Q) {
      var alpha = Math.sin(w0) / (2 * Q);
      var k = Math.cos(w0);

      var b0 = alpha;
      var b1 = 0;
      var b2 = -alpha;
      var a0 = 1 + alpha;
      var a1 = -2 * k;
      var a2 = 1 - alpha;

      return [b0 / a0, b1 / a0, b2 / a0, a1 / a0, a2 / a0];
    }

    return [1, 0, 0, 0, 0];
  }

  return [0, 0, 0, 0, 0];
};

computeCoefficients[LOWSHELF] = function (frequency, _, dbGain) {
  frequency = Math.max(0.0, Math.min(frequency, 1.0));

  var A = Math.pow(10.0, dbGain / 40);

  if (frequency == 1) {
    return [A * A, 0, 0, 0, 0];
  }

  if (0 < frequency) {
    var w0 = Math.PI * frequency;
    var S = 1;
    var alpha = 0.5 * Math.sin(w0) * Math.sqrt((A + 1 / A) * (1 / S - 1) + 2);
    var k = Math.cos(w0);
    var k2 = 2 * Math.sqrt(A) * alpha;
    var aPlusOne = A + 1;
    var aMinusOne = A - 1;

    var b0 = A * (aPlusOne - aMinusOne * k + k2);
    var b1 = 2 * A * (aMinusOne - aPlusOne * k);
    var b2 = A * (aPlusOne - aMinusOne * k - k2);
    var a0 = aPlusOne + aMinusOne * k + k2;
    var a1 = -2 * (aMinusOne + aPlusOne * k);
    var a2 = aPlusOne + aMinusOne * k - k2;

    return [b0 / a0, b1 / a0, b2 / a0, a1 / a0, a2 / a0];
  }

  return [1, 0, 0, 0, 0];
};

computeCoefficients[HIGHSHELF] = function (frequency, _, dbGain) {
  frequency = Math.max(0.0, Math.min(frequency, 1.0));

  var A = Math.pow(10.0, dbGain / 40);

  if (frequency == 1) {
    return [1, 0, 0, 0, 0];
  }

  if (0 < frequency) {
    var w0 = Math.PI * frequency;
    var S = 1;
    var alpha = 0.5 * Math.sin(w0) * Math.sqrt((A + 1 / A) * (1 / S - 1) + 2);
    var k = Math.cos(w0);
    var k2 = 2 * Math.sqrt(A) * alpha;
    var aPlusOne = A + 1;
    var aMinusOne = A - 1;

    var b0 = A * (aPlusOne + aMinusOne * k + k2);
    var b1 = -2 * A * (aMinusOne + aPlusOne * k);
    var b2 = A * (aPlusOne + aMinusOne * k - k2);
    var a0 = aPlusOne - aMinusOne * k + k2;
    var a1 = 2 * (aMinusOne - aPlusOne * k);
    var a2 = aPlusOne - aMinusOne * k - k2;

    return [b0 / a0, b1 / a0, b2 / a0, a1 / a0, a2 / a0];
  }

  return [A * A, 0, 0, 0, 0];
};

computeCoefficients[PEAKING] = function (frequency, Q, dbGain) {
  frequency = Math.max(0.0, Math.min(frequency, 1.0));
  Q = Math.max(0.0, Q);

  var A = Math.pow(10.0, dbGain / 40);

  if (0 < frequency && frequency < 1) {
    if (0 < Q) {
      var w0 = Math.PI * frequency;
      var alpha = Math.sin(w0) / (2 * Q);
      var k = Math.cos(w0);

      var b0 = 1 + alpha * A;
      var b1 = -2 * k;
      var b2 = 1 - alpha * A;
      var a0 = 1 + alpha / A;
      var a1 = -2 * k;
      var a2 = 1 - alpha / A;

      return [b0 / a0, b1 / a0, b2 / a0, a1 / a0, a2 / a0];
    }

    return [A * A, 0, 0, 0, 0];
  }

  return [1, 0, 0, 0, 0];
};

computeCoefficients[NOTCH] = function (frequency, Q) {
  frequency = Math.max(0.0, Math.min(frequency, 1.0));
  Q = Math.max(0.0, Q);

  if (0 < frequency && frequency < 1) {
    if (0 < Q) {
      var w0 = Math.PI * frequency;
      var alpha = Math.sin(w0) / (2 * Q);
      var k = Math.cos(w0);

      var b0 = 1;
      var b1 = -2 * k;
      var b2 = 1;
      var a0 = 1 + alpha;
      var a1 = -2 * k;
      var a2 = 1 - alpha;

      return [b0 / a0, b1 / a0, b2 / a0, a1 / a0, a2 / a0];
    }

    return [0, 0, 0, 0, 0];
  }

  return [1, 0, 0, 0, 0];
};

computeCoefficients[ALLPASS] = function (frequency, Q) {
  frequency = Math.max(0.0, Math.min(frequency, 1.0));
  Q = Math.max(0.0, Q);

  if (0 < frequency && frequency < 1) {
    if (0 < Q) {
      var w0 = Math.PI * frequency;
      var alpha = Math.sin(w0) / (2 * Q);
      var k = Math.cos(w0);

      var b0 = 1 - alpha;
      var b1 = -2 * k;
      var b2 = 1 + alpha;
      var a0 = 1 + alpha;
      var a1 = -2 * k;
      var a2 = 1 - alpha;

      return [b0 / a0, b1 / a0, b2 / a0, a1 / a0, a2 / a0];
    }

    return [-1, 0, 0, 0, 0];
  }

  return [1, 0, 0, 0, 0];
};

function flushDenormalFloatToZero(f) {
  return Math.abs(f) < 1.175494e-38 ? 0.0 : f;
}

BiquadFilterNodeDSP.FilterTypes = FilterTypes;
BiquadFilterNodeDSP.LOWPASS = LOWPASS;
BiquadFilterNodeDSP.HIGHPASS = HIGHPASS;
BiquadFilterNodeDSP.BANDPASS = BANDPASS;
BiquadFilterNodeDSP.LOWSHELF = LOWSHELF;
BiquadFilterNodeDSP.HIGHSHELF = HIGHSHELF;
BiquadFilterNodeDSP.PEAKING = PEAKING;
BiquadFilterNodeDSP.NOTCH = NOTCH;
BiquadFilterNodeDSP.ALLPASS = ALLPASS;

module.exports = BiquadFilterNodeDSP;
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PeriodicWaveDSP = require("./dsp/PeriodicWave");

var PeriodicWave = function () {
  /**
   * @param {AudioContext} context
   * @param {object}       opts
   * @param {Float32Array} opts.real
   * @param {Float32Array} opts.imag
   * @param {boolean}      opts.constraints
   */

  function PeriodicWave(context, opts) {
    _classCallCheck(this, PeriodicWave);

    opts = opts || /* istanbul ignore next */{};

    var real = opts.real;
    var imag = opts.imag;
    var constraints = opts.constraints;

    this.context = context;
    this._real = real;
    this._imag = imag;
    this._constants = !!constraints;
    this._name = "custom";

    this.dspInit();
  }

  /**
   * @return {Float32Array}
   */


  _createClass(PeriodicWave, [{
    key: "getReal",
    value: function getReal() {
      return this._real;
    }

    /**
     * @return {Float32Array}
     */

  }, {
    key: "getImag",
    value: function getImag() {
      return this._imag;
    }

    /**
     * @return {booleam}
     */

  }, {
    key: "getConstraints",
    value: function getConstraints() {
      return this._constants;
    }

    /**
     * @return {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }

    /**
     * @return {Float32Array}
     */

  }, {
    key: "getWaveTable",
    value: function getWaveTable() {
      if (!this._waveTable) {
        this._waveTable = this.dspBuildWaveTable();
      }
      return this._waveTable;
    }
  }, {
    key: "generateBasicWaveform",
    value: function generateBasicWaveform(type) {
      var length = 512;

      switch (type) {
        case "sine":
          this._real = new Float32Array([0, 0]);
          this._imag = new Float32Array([0, 1]);
          this._name = "sine";
          break;
        case "sawtooth":
          this._real = new Float32Array(length);
          this._imag = new Float32Array(Array.from({ length: length }, function (_, n) {
            return n === 0 ? 0 : Math.pow(-1, n + 1) * (2 / (n * Math.PI));
          }));
          this._name = "sawtooth";
          this.dspBuildWaveTable();
          break;
        case "triangle":
          this._real = new Float32Array(length);
          this._imag = new Float32Array(Array.from({ length: length }, function (_, n) {
            return n === 0 ? 0 : 8 * Math.sin(n * Math.PI / 2) / Math.pow(n * Math.PI, 2);
          }));
          this._name = "triangle";
          this.dspBuildWaveTable();
          break;
        case "square":
          this._real = new Float32Array(length);
          this._imag = new Float32Array(Array.from({ length: length }, function (_, n) {
            return n === 0 ? 0 : 2 / (n * Math.PI) * (1 - Math.pow(-1, n));
          }));
          this._name = "square";
          this.dspBuildWaveTable();
          break;
        default:
          this._real = new Float32Array([0]);
          this._imag = new Float32Array([0]);
          this._name = "custom";
          this.dspBuildWaveTable();
          break;
      }
    }
  }]);

  return PeriodicWave;
}();

PeriodicWave.BasicWaveForms = ["sine", "sawtooth", "triangle", "square"];

Object.assign(PeriodicWave.prototype, PeriodicWaveDSP);

module.exports = PeriodicWave;